---
title: "Multi-Agent Integration(Orchestrator)"
description: "Build the brain of your multi-agent system"
duration: "75 minutes"
difficulty: "Advanced"
objectives:
  - "Implement intent parsing with Gemini"
  - "Build task routing logic"
  - "Orchestrate multi-step workflows"
---

import { CodeBlock } from '@/components/workshop/CodeBlock';
import { Exercise } from '@/components/workshop/Exercise';
import { Hint } from '@/components/workshop/Hint';
import { Checkpoint } from '@/components/workshop/Checkpoint';
import { TestButton } from '@/components/workshop/TestButton';

## Overview

The **Orchestrator Agent** is the brain of your multi-agent system. It coordinates complex workflows by:
1. **Parsing intents** - Understanding user queries with Gemini
2. **Routing tasks** - Directing work to specialized agents (Analytics, Report)
3. **Orchestrating workflows** - Coordinating multi-step operations (analytics ‚Üí report ‚Üí email)

In this tutorial, you'll build the complete orchestrator from scratch!

## Architecture

<CodeBlock language="typescript" code={`// High-level flow
User Query ‚Üí parseIntent() ‚Üí routeTask() ‚Üí handleMultiStepQuery()
              ‚Üì               ‚Üì              ‚Üì
           Gemini AI     Agent Type    Analytics ‚Üí Report ‚Üí Email`} />

## Key Concepts

### Intent Classification
The orchestrator classifies user queries into four intent types:
- **analytics** - Data queries (revenue, top products, user behavior)
- **report** - Report generation requests
- **email** - Email sending requests
- **multi_step** - Complex queries requiring multiple agents

### Entity Extraction
From natural language, extract:
- **query_type** - Which analytics query to run
- **time_range** - Time period (if specified)
- **recipient** - Email address (if specified)

### Supported Query Types
- `revenue` - Total revenue, purchases, customer metrics
- `top_products` - Best-selling products with revenue data
- `user_behavior` - Event counts and user engagement
- `category_performance` - Performance by product category
- `brand_analysis` - Performance by brand

##  Implement parseIntent with Gemini

Let's build the `parseIntent` method that uses Gemini to analyze user queries.

<Exercise title="Implement intent parsing with Gemini">

**üìù File:** `src/lib/agents/orchestrator.ts`

Implement the `parseIntent` method.

**Requirements:**
1. Use Gemini to analyze the user query
2. Return structured JSON with: `intent`, `entities`, and `confidence`
3. Handle all 4 intent types and 5 query types
4. Extract time ranges and email addresses from queries
5. Parse JSON from Gemini's response (handle code blocks)

**Prompt Structure:**
- Explain the system capabilities
- Provide the user query
- Request JSON response format
- Give examples for each intent type

**Example queries to handle:**
- "Show me revenue" ‚Üí `{intent: "analytics", entities: {query_type: "revenue"}}`
- "Generate report and email to john@example.com" ‚Üí `{intent: "multi_step", entities: {recipient: "john@example.com"}}`
- "Top selling products" ‚Üí `{intent: "analytics", entities: {query_type: "top_products"}}`

<Hint title="Full implementation (click to reveal)">
<CodeBlock language="typescript" code={`async parseIntent(userQuery: string): Promise<IntentResult> {
  const prompt = \`
  Analyze this user query and classify the intent for an ecommerce analytics system:
  Query: "\${userQuery}"
  
  Context: The system can:
  - Run analytics queries (revenue, top products, user behavior, category/brand analysis)
  - Generate reports (summary or financial)
  - Send emails with reports
  - Handle multi-step queries that combine the above
  
  Respond in JSON format:
  {
    "intent": "analytics" | "report" | "email" | "multi_step",
    "entities": {
      "query_type": "revenue|top_products|user_behavior|category_performance|brand_analysis",
      "time_range": "time period if specified",
      "recipient": "email address if specified"
    },
    "confidence": 0.0 to 1.0
  }
  
  Examples:
  - "Show me revenue" -> intent: analytics, query_type: revenue
  - "Top selling products" -> intent: analytics, query_type: top_products
  - "Generate report and email to john@example.com" -> intent: multi_step, recipient: john@example.com
  - "How are users behaving?" -> intent: analytics, query_type: user_behavior
  - "Best performing brands" -> intent: analytics, query_type: brand_analysis
  \`;
  
  const result = await this.model.generateContent(prompt);
  const responseText = result.response.text();
  
  // Clean up the response to extract JSON
  const jsonMatch = responseText.match(/\\{[\\s\\S]*\\}/);
  if (!jsonMatch) {
    throw new Error('Failed to parse intent from Gemini response');
  }
  
  return JSON.parse(jsonMatch[0]);
}`} />
</Hint>

**Key implementation details:**
- Use `this.model.generateContent()` for Gemini API call
- Use regex `/{[\s\S]*}/` to extract JSON from markdown code blocks
- Throw error if JSON parsing fails
- Return typed `IntentResult` object

</Exercise>

##  Implement Task Routing

Build the `routeTask` method that maps intents to agent types.

<Exercise title="Implement task routing logic">

**üìù File:** `src/lib/agents/orchestrator.ts`

Implement the `routeTask` method in `src/lib/agents/orchestrator.ts`.

**Requirements:**
1. Take an `IntentResult` as input
2. Map intent to appropriate `AgentType`
3. Return `'analytics'`, `'report'`, `'email'`, or `'unknown'`

**Routing rules:**
- `intent: 'analytics'` ‚Üí `'analytics'` agent
- `intent: 'report'` ‚Üí `'report'` agent
- `intent: 'email'` ‚Üí `'email'` agent
- Anything else ‚Üí `'unknown'`

<Hint title="Full implementation (click to reveal)">
<CodeBlock language="typescript" code={`routeTask(intent: IntentResult): AgentType {
  if (intent.intent === 'analytics') return 'analytics';
  if (intent.intent === 'report') return 'report';
  if (intent.intent === 'email') return 'email';
  return 'unknown';
}`} />
</Hint>

**Note:** For `multi_step` intents, we use `handleMultiStepQuery()` instead of routing to a single agent.

</Exercise>

<Checkpoint items={[
  "parseIntent uses Gemini to analyze natural language queries",
  "Intent parsing returns structured JSON with intent, entities, confidence",
  "JSON extraction handles Gemini's markdown code blocks",
  "routeTask maps intents to correct agent types",
  "Error handling throws descriptive errors for parsing failures"
]} />

## Exercise 1: Implement Multi-Step Orchestration (TODO)

Now for the main event: orchestrating complex workflows that coordinate multiple agents!

<Exercise title="Complete the handleMultiStepQuery method">

**üìù File:** `src/lib/agents/orchestrator.ts`

Look for the `TODO: Exercise 1` comment in the file. The entire orchestration workflow is already implemented - you just need to complete **3 lines** at the top!

**üéØ Your Task :**

Replace these three lines:
```typescript
const intent = null; 
const queryType = null; 
const recipient = null; 
```

With the correct implementation:
1. **Line 1:** Parse the intent using `this.parseIntent(userQuery)`
2. **Line 2:** Extract query type from `intent.entities.query_type`
3. **Line 3:** Extract recipient from `intent.entities.recipient`

**‚ú® Everything else is done for you!** The code already:
- ‚úÖ Executes analytics queries
- ‚úÖ Generates financial/summary reports
- ‚úÖ Sends emails with proper subjects
- ‚úÖ Tracks steps and handles errors



<Hint title="Solution (click to reveal)">
<CodeBlock language="typescript" code={`// Replace these 3 lines:
const intent = await this.parseIntent(userQuery);
const queryType = intent.entities.query_type;
const recipient = intent.entities.recipient;`} />
</Hint>

**That's it!** The rest of the method handles:
- Analytics execution
- Report generation (financial vs summary)
- Email sending with proper subjects
- Step tracking and error handling

**Test queries to try:**
- "Show me revenue and email to alice@example.com"
- "Top selling products"
- "Generate brand analysis report and send to manager@company.com"

**Test queries:**
- "Show revenue and send report to alice@example.com"
- "Top selling products and email to manager@company.com"
- "Generate a financial report for brand analysis"
- "Analyze user behavior and send summary report"

</Exercise>

##  Build the Orchestrator API Route

Create the API endpoint that exposes the orchestrator.

<Exercise title="Implement the Orchestrator API route">

**üìù File:** `src/app/api/orchestrator/route.ts`

Open `src/app/api/orchestrator/route.ts` and implement both POST and GET endpoints.

**POST endpoint requirements:**
1. Extract `query` and `action` from request body
2. Validate that `query` is provided
3. Validate `GEMINI_API_KEY` is configured
4. Support two actions:
   - `'parse'` - Just parse intent and route
   - `'execute'` or `'multi_step'` - Execute full workflow
5. Return appropriate JSON responses

**GET endpoint requirements:**
1. Return capabilities documentation
2. List supported actions and intents
3. Provide example queries

<Hint title="Full implementation (click to reveal)">
<CodeBlock language="typescript" code={`import { NextRequest, NextResponse } from 'next/server';
import { OrchestratorAgent } from '@/lib/agents/orchestrator';

export async function POST(request: NextRequest) {
  try {
    const { query, action = 'parse' } = await request.json();
    
    if (!query) {
      return NextResponse.json(
        { error: 'query parameter is required' }, 
        { status: 400 }
      );
    }
    
    const apiKey = process.env.GEMINI_API_KEY;
    if (!apiKey || apiKey === 'your_api_key_here') {
      return NextResponse.json(
        { 
          error: 'GEMINI_API_KEY not configured. Please set it in your .env file.',
          hint: 'Get your API key from https://aistudio.google.com'
        }, 
        { status: 500 }
      );
    }
    
    const orchestrator = new OrchestratorAgent(apiKey);
    
    // Support both intent parsing and multi-step execution
    if (action === 'execute' || action === 'multi_step') {
      const result = await orchestrator.handleMultiStepQuery(query);
      return NextResponse.json({
        action: 'multi_step_execution',
        query,
        ...result
      });
    }
    
    // Default: parse intent and route
    const intent = await orchestrator.parseIntent(query);
    const route = orchestrator.routeTask(intent);
    
    return NextResponse.json({ 
      success: true,
      action: 'intent_parsing',
      query,
      intent, 
      route 
    });
  } catch (error: any) {
    console.error('Orchestrator API error:', error);
    return NextResponse.json(
      { 
        success: false,
        error: error?.message ?? 'Unknown error',
        details: process.env.NODE_ENV === 'development' ? error?.stack : undefined
      }, 
      { status: 500 }
    );
  }
}

// Add GET endpoint for capabilities
export async function GET() {
  return NextResponse.json({
    capabilities: {
      actions: ['parse', 'execute', 'multi_step'],
      supportedIntents: ['analytics', 'report', 'email', 'multi_step'],
      features: [
        'Natural language query parsing',
        'Multi-agent orchestration',
        'Email delivery with reports',
        'Complex workflow execution'
      ]
    },
    examples: [
      {
        query: 'Show me revenue for the last 30 days',
        action: 'parse',
        description: 'Parse intent and determine routing'
      },
      {
        query: 'Generate a revenue report and email it to user@example.com',
        action: 'execute',
        description: 'Execute multi-step workflow'
      }
    ]
  });
}`} />
</Hint>

**Test your API:**
```bash
# Get capabilities
curl http://localhost:3000/api/orchestrator

# Parse intent only
curl -X POST http://localhost:3000/api/orchestrator \
  -H "Content-Type: application/json" \
  -d '{"query": "Show me revenue", "action": "parse"}'

# Execute multi-step workflow
curl -X POST http://localhost:3000/api/orchestrator \
  -H "Content-Type: application/json" \
  -d '{"query": "Show revenue and email to test@example.com", "action": "execute"}'
```

</Exercise>

<Checkpoint items={[
  "handleMultiStepQuery detects all 5 query types using regex",
  "Steps are tracked in order with status (completed/failed)",
  "Analytics agent is called and results are captured",
  "Report agent generates financial or summary reports based on query type",
  "Email is sent when recipient is detected in query",
  "Error handling adds error step and returns success: false",
  "API route supports both 'parse' and 'execute' actions",
  "API validates GEMINI_API_KEY before processing"
]} />

## Understanding the Integration Flow

Let's trace a complete workflow through the system:

### Example: "Show revenue and send report to alice@example.com"

<CodeBlock language="typescript" code={`// Step 1: API receives request
POST /api/orchestrator
{ query: "Show revenue and send report to alice@example.com", action: "execute" }

// Step 2: Orchestrator detects intents
hasRevenue = true  // matches /revenue/
hasReport = true   // matches /report/
recipient = "alice@example.com"  // matches email regex

// Step 3: Execute analytics query
const analytics = new AnalyticsAgent();
const result = await analytics.executeQuery('revenue');
// ‚Üí { total_revenue: 1234567, total_purchases: 8542, ... }

// Step 4: Generate financial report
const reportAgent = new ReportAgent(apiKey);
const report = await reportAgent.generateFinancialReport(result);
// ‚Üí "Executive Summary: Total revenue of $1.23M from 8,542 purchases..."

// Step 5: Send email
await reportAgent.sendEmail(
  "alice@example.com",
  "Revenue Analysis Report",
  report
);
// ‚Üí Email preview logged to console (sandbox mode)

// Step 6: Return complete workflow result
return {
  success: true,
  totalSteps: 3,
  steps: [
    { step: 'analytics', action: 'revenue_query', status: 'completed' },
    { step: 'report', action: 'generate_financial_report', status: 'completed' },
    { step: 'email', action: 'send_report', status: 'completed' }
  ]
}`} />

## Error Handling & Resilience

### Rate Limiting with Gemini Free Tier

Gemini's free tier has a 15 RPM limit. Handle it with retries and rate limiting:

<CodeBlock language="typescript" code={`import { withRetry, createRateLimiter } from '@/lib/utils/error-handler';

// Create rate limiter (15 requests per minute)
const rateLimiter = createRateLimiter(15);

// Wrap Gemini calls with retry logic
async parseIntent(userQuery: string): Promise<IntentResult> {
  await rateLimiter.removeToken(); // Wait if rate limit reached
  
  const result = await withRetry(
    () => this.model.generateContent(prompt),
    {
      retries: 3,
      initialDelayMs: 500,
      maxDelayMs: 5000,
      onRetry: (attempt, error) => {
        console.log(\`Retry attempt \${attempt}:\`, error);
      }
    }
  );
  
  // ... parse response
}`} />

### Handling GEMINI_API_KEY Errors

<CodeBlock language="typescript" code={`constructor(apiKey: string) {
  if (!apiKey || apiKey === 'your_api_key_here') {
    throw new Error('Valid GEMINI_API_KEY is required for OrchestratorAgent');
  }
  
  this.apiKey = apiKey;
  const genAI = new GoogleGenerativeAI(apiKey);
  this.model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });
}`} />

## Test

<TestButton label="Test Orchestrator End-to-End" message="Use the Orchestrator Demo to test complex multi-step queries!" />

**Complete test checklist:**

**Intent Parsing:**
- ‚úÖ "Show me revenue" ‚Üí analytics intent, revenue query_type
- ‚úÖ "Top selling products" ‚Üí analytics intent, top_products query_type
- ‚úÖ "Generate report" ‚Üí report intent
- ‚úÖ "Email to user@test.com" ‚Üí email intent with recipient

**Multi-Step Execution:**
- ‚úÖ "Show revenue and send report to alice@example.com" ‚Üí 3 steps
- ‚úÖ "Top products and email to manager@company.com" ‚Üí 3 steps
- ‚úÖ "Generate financial report for brand analysis" ‚Üí 2 steps
- ‚úÖ "Analyze user behavior" ‚Üí 1 step

**Error Handling:**
- ‚úÖ Invalid GEMINI_API_KEY returns 500 error
- ‚úÖ Missing query parameter returns 400 error
- ‚úÖ Gemini parsing failure throws descriptive error

**Email Preview:**
- ‚úÖ Open browser console (F12)
- ‚úÖ Check for "üìß Email Preview (Sandbox Mode)" output
- ‚úÖ Verify recipient, subject, and body are logged

## Advanced: Extending the Orchestrator

### Add Time Range Extraction

<CodeBlock language="typescript" code={`// In handleMultiStepQuery, extract time ranges
const timeMatch = lower.match(/(last|past)\\s+(\\d+)\\s+(days?|weeks?|months?)/);
if (timeMatch) {
  const amount = parseInt(timeMatch[2]);
  const unit = timeMatch[3];
  // Pass to analytics query with custom time range
}`} />

### Add Multiple Email Recipients

<CodeBlock language="typescript" code={`// Support comma-separated email lists
const recipientMatches = userQuery.match(/[\\w.-]+@[\\w.-]+\\.[a-z]{2,}/g);
if (recipientMatches && recipientMatches.length > 1) {
  for (const recipient of recipientMatches) {
    await reportAgent.sendEmail(recipient, subject, report);
  }
}`} />

### Add Scheduled Reports

<CodeBlock language="typescript" code={`// Detect scheduling requests
const hasSchedule = /daily|weekly|monthly|schedule/.test(lower);
if (hasSchedule) {
  const schedule = extractSchedule(userQuery);
  await scheduleReport(queryType, recipient, schedule);
}`} />

### Add Custom Query Types

<CodeBlock language="typescript" code={`// Add conversion funnel support
const hasFunnel = /conversion|funnel|customer\\s+journey/.test(lower);

if (hasFunnel) {
  queryType = 'conversion_funnel';
  analyticsResult = await analytics.getConversionFunnel();
}`} />

## Production Deployment Checklist

When deploying to production:

**Environment Variables:**
```bash
GEMINI_API_KEY=your_production_key
FIREBOLT_CLIENT_ID=your_client_id
FIREBOLT_CLIENT_SECRET=your_client_secret
FIREBOLT_ACCOUNT=your_account
FIREBOLT_DATABASE=ecommercedb
GMAIL_USER=your_gmail@gmail.com
GMAIL_APP_PASSWORD=your_app_password
NODE_ENV=production
```

**Monitoring:**
- Log all orchestration steps for debugging
- Track failed steps and error rates
- Monitor Gemini API usage and rate limits
- Alert on repeated orchestration failures

**Security:**
- Validate and sanitize email addresses
- Rate limit API endpoints to prevent abuse
- Add authentication to orchestrator API
- Sanitize user queries before sending to Gemini

**Performance:**
- Cache intent parsing results for common queries
- Implement query result caching in Analytics Agent
- Use Firebolt materialized views for frequent queries
- Add indexes on commonly filtered columns